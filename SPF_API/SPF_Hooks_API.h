#pragma once

#include <stdbool.h> // For bool
#include <stdint.h> // For uintptr_t

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Opaque handle to a registered hook instance.
 */
typedef struct SPF_Hook_Handle SPF_Hook_Handle;

/**
 * @brief Typedef for the function that finds a function by signature and installs a hook.
 *
 * @param pluginName The name of the calling plugin.
 * @param hookName A unique programmatic name for the hook (e.g., "MyPlugin_TrafficHook").
 * @param displayName A user-friendly name for display in UI menus.
 * @param pDetour A pointer to your detour function. This function will be called instead
 *                of the original. It must match the original function's signature.
 * @param ppOriginal A pointer to a function pointer variable. The framework will store the
 *                   address of the trampoline here. You must use this to call the
 *                   original function from your detour.
 * @param signature A string representing the byte pattern for the hook target.
 * @param isEnabled The initial enabled state of the hook.
 * @return A handle to the hook, or NULL on failure. The framework manages the memory.
 */
typedef SPF_Hook_Handle* (*SPF_Hooks_Register_t)(const char* pluginName, const char* hookName, const char* displayName, void* pDetour, void** ppOriginal, const char* signature, bool isEnabled);

/**
 * @brief Finds a byte pattern in the game's memory.
 *
 * @param signature A string representing the byte pattern (e.g., "48 89 5C 24 ? 57 48 83").
 *                  Use '?' or '??' for wildcards.
 * @return The memory address where the pattern was found, or 0 if not found.
 */
typedef uintptr_t (*SPF_Hooks_FindPattern_t)(const char* signature);

/**
 * @brief Finds a byte pattern within a specific memory range.
 *
 * @param signature A string representing the byte pattern.
 * @param startAddress The base address to start searching from.
 * @param searchLength The size of the memory block to search.
 * @return The memory address where the pattern was found, or 0 if not found.
 */
typedef uintptr_t (*SPF_Hooks_FindPatternFrom_t)(const char* signature, uintptr_t startAddress, size_t searchLength);

/**
 * @brief Checks if a hook is currently enabled in the configuration.
 * @param handle The handle to the hook instance.
 * @return True if the hook is enabled, false otherwise.
 */
typedef bool (*SPF_Hooks_IsEnabled_t)(SPF_Hook_Handle* handle);

/**
 * @brief Checks if a hook is currently installed (i.e., active in memory).
 * @param handle The handle to the hook instance.
 * @return True if the hook is installed, false otherwise.
 */
typedef bool (*SPF_Hooks_IsInstalled_t)(SPF_Hook_Handle* handle);


/**
 * @struct SPF_Hooks_API
 * @brief C-style API for finding memory patterns and hooking game functions.
 *
 * @details This API provides plugins with the ability to intercept and execute custom
 *          code before, after, or instead of a native game function. It uses
 *          pattern scanning to find functions in memory and relies on MinHook
 *          for creating the low-level hooks.
 *
 * @section Core Concepts
 * 1.  **Signature**: A unique sequence of bytes representing the beginning of a
 *     function in memory. This is used to find the function's address, which
 *     can change between game updates. Wildcards ('?' or '??') can be used for
 *     bytes that might change.
 * 2.  **Detour**: Your C++ function that will be executed when the game tries to
 *     call the original function. It MUST have the exact same function signature
 *     (calling convention, parameters, and return type) as the function you are hooking.
 * 3.  **Trampoline (`ppOriginal`)**: A pointer to a small piece of executable code
 *     generated by the hooking library. This trampoline, when called, executes the
 *     original game function. You **must** call the original function via this
 *     pointer from your detour to ensure the game continues to function correctly.
 *
 * @section Workflow
 * 1.  **Find Signature**: Using a disassembler or memory scanner (like Ghidra, x64dbg,
 *     or Cheat Engine), find the target function and identify a unique byte
 *     pattern at its start.
 * 2.  **Define Function Type**: In your C++ code, define a type for a function
 *     pointer that matches the original function's signature.
 * 3.  **Implement Detour**: Write your detour function. It should accept the same
 *     parameters and return the same type as the original. Inside this function,
 *     you can add your custom logic.
 * 4.  **Call the Original**: Inside your detour, you must call the original function
 *     using the trampoline pointer provided by the `Register` function. This is
 *     critical to avoid crashing the game.
 * 5.  **Register Hook**: In your plugin's `OnLoad` function, call `Register`,
 *     providing the signature, pointers to your detour and trampoline, and other
 *     metadata. The framework will then find the function and install the hook.
 *
 * @section Example
 * @code{.cpp}
 * // 1. Define the original function's signature
 * using MyFunction_t = void(*)(int, bool);
 *
 * // 2. Create a global pointer for the trampoline
 * static MyFunction_t o_MyFunction = nullptr;
 *
 * // 3. Implement your detour
 * void Detour_MyFunction(int param1, bool param2) {
 *     // Your custom logic here...
 *     Log("MyFunction was called!");
 *
 *     // 4. Call the original function
 *     return o_MyFunction(param1, param2);
 * }
 *
 * // 5. In OnLoad:
 * void OnLoad(const SPF_Core_API* core) {
 *     core->hooks->Register(
 *         "MyPlugin",
 *         "MyFunctionHook",
 *         "My Function Hook",
 *         &Detour_MyFunction,
 *         (void**)&o_MyFunction,
 *         "48 89 5C 24 ? 57 48 83 EC 60",
 *         true
 *     );
 * }
 * @endcode
 */
// The API struct that the framework provides to the plugin.
typedef struct {
    /**
     * @brief Finds a function by its byte signature and installs a hook.
     *
     * @param pluginName The name of the calling plugin.
     * @param hookName A unique programmatic name for the hook (e.g., "MyPlugin_TrafficHook").
     * @param displayName A user-friendly name for display in UI menus.
     * @param pDetour A pointer to your detour function. This function will be called instead
     *                of the original. It must match the original function's signature.
     * @param ppOriginal A pointer to a function pointer variable. The framework will store the
     *                   address of the trampoline here. You must use this to call the
     *                   original function from your detour.
     * @param signature A string representing the byte pattern for the hook target.
     * @param isEnabled The initial enabled state of the hook.
     * @return A handle to the hook, or NULL on failure. The framework manages the memory.
     */
    SPF_Hooks_Register_t Register;
    SPF_Hooks_FindPattern_t FindPattern;

    /**
     * @brief Finds a byte pattern within a specific memory range.
     *
     * @param signature A string representing the byte pattern.
     * @param startAddress The base address to start searching from.
     * @param searchLength The size of the memory block to search.
     * @return The memory address where the pattern was found, or 0 if not found.
     */
    SPF_Hooks_FindPatternFrom_t FindPatternFrom;

    SPF_Hooks_IsEnabled_t IsEnabled;
    SPF_Hooks_IsInstalled_t IsInstalled;
} SPF_Hooks_API;




#ifdef __cplusplus
}
#endif